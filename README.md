# Zardous
Zardous这个名字取自英文"harzadous"，指灾害风险。就像这个系统一样，当你使用和开发这个系统的时候会直面各种风险，因为你可以任意修改存储器中的内容，而没有什么防护措施。因此这就意味着这个系统必须保持比较小的规模，否则其快速升高的复杂程度和风险会让使用者难以继续使用。

# 初衷/Motivation/Rationale

0. **一个geek的必由之路**

和所有打算自己实现一个操作系统的朋友一样，受Linux如何诞生的故事所激励，希望能全面了解计算机的硬件结构，就是被现有的操作系统所隐藏的各种细节，也希望弄明白一个操作系统到底是如何工作的。目前操作系统的架构以及设计实现也非常成熟，大部分学校的计算机系都开设操作系统课程，即使你没有自己实现操作系统，也能明白它如何实现内存和其他硬件资源的管理，进程调度，进程间通信，以及网络等等。你只要遵循所学到的知识，读源码，看教程，然后从一个汇编代码的bootloader写起，逐步加载一个用C写的内核镜像，包括虚拟内存管理，调度器，等等。目前大部分能够找到的homebrew操作系统源码，大概都遵循这个套路。但是有一些事情让我觉得我有必要做一些不同的尝试。

1. **一个不同的汇编语言开发方式**

正如你看到Zardous里所有的代码都是用汇编写的一样。在十年前的《计算机体系结构》课程里，基本上将一台计算机当作一个Arduino控制各种周边设备。当时我们都是在使用汇编进行开发。在当时所接触到的汇编器中都具有强大的宏定义功能，通过它可以写出高度模块化且可重用的汇编代码。但是一直到今天都很少有人作出同样的尝试。GitHub上也有不少用纯汇编写的操作系统项目，但是和以往所有对汇编语言的批判一样，非常混乱且很难读懂。那么是否存在这样的可能性，即如果我们使用同样的开发方式编写汇编代码，在开发效率上不会产生较大的损失，但是在性能上可以获得极大的提升呢？

(上面的内容是我当两年前准备开始这个项目的时候写的，事实上是开发效率上的的确确会产生巨大的效率损失，但是性能上极大的提升很难预期。但毕竟现阶段仍然是在开发这个系统，而不是使用它。)

直到我看到了一个项目叫做[JonesForth](http://git.annexia.org/?p=jonesforth.git;a=summary)。这个项目包含这套语言本身的定义，以及实现对这个语言的解释器的设计细节。Zardous本身的设计思路也深受Forth影响，会在下文更详细地阐明。项目代码沿用了DEK的文档式编程的思路，介绍了一种非常先进的汇编代码组织思路，同时也构成了Forth实现的基础。大体思路是，你需要为自己建立一套基础设施，这个基础设施不一定直接和项目的逻辑有关，但是却能够为之后的代码带来极大的便利和灵活。一言以蔽之就是『磨刀不误砍柴工』。

2. **Forth是什么以及为什么要用Forth**

从**语言设计**的层次，Forth是一个连接式语言（concatenative language），也就是说语言的语法要素通过前后连接而成，不像高级语言如C/Lisp有括号和引号等专门指示代码结构的语法要素，也就是说实际上Forth是顺序执行一系列的关键字。从**语言实现**的层次，Forth包含有一个可以不断扩充的关键字字典。关键字既可以对应到一段汇编代码，也可以对应到其它关键字的序列组合。

这样使得Forth所对应的汇编代码有些不同的特点。对于POSIX兼容的嵌套函数调用，每次调用函数之前，都先需要将所有寄存器中的内容压入栈中，调用结束后再弹出。然而在Forth所对应的系统，寄存器是全局的中转站，因此和POSIX正相反，是进入下一个子过程前时将结果保存至寄存器里，进入后再从寄存器中取回数据。
